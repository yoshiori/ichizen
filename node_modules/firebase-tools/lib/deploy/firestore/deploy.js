"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const clc = require("colorette");
const api_1 = require("../../firestore/api");
const types = require("../../firestore/api-types");
const logger_1 = require("../../logger");
const utils = require("../../utils");
const rulesDeploy_1 = require("../../rulesDeploy");
const utils_1 = require("../../utils");
const error_1 = require("../../error");
async function createDatabase(context, options) {
    let firestoreCfg = options.config.data.firestore;
    if (Array.isArray(firestoreCfg)) {
        firestoreCfg = firestoreCfg[0];
    }
    if (!options.projectId) {
        throw new error_1.FirebaseError("Project ID is required to create a Firestore database.");
    }
    if (!firestoreCfg) {
        throw new error_1.FirebaseError("Firestore database configuration not found in firebase.json.");
    }
    if (!firestoreCfg.database) {
        firestoreCfg.database = "(default)";
    }
    const api = new api_1.FirestoreApi();
    try {
        await api.getDatabase(options.projectId, firestoreCfg.database);
    }
    catch (e) {
        if (e.status === 404) {
            utils.logLabeledBullet("firetore", `Creating the new Firestore database ${firestoreCfg.database}...`);
            const createDatabaseReq = {
                project: options.projectId,
                databaseId: firestoreCfg.database,
                locationId: firestoreCfg.location || "nam5",
                type: types.DatabaseType.FIRESTORE_NATIVE,
                deleteProtectionState: types.DatabaseDeleteProtectionState.DISABLED,
                pointInTimeRecoveryEnablement: types.PointInTimeRecoveryEnablement.DISABLED,
            };
            await api.createDatabase(createDatabaseReq);
        }
    }
}
async function deployRules(context) {
    var _a;
    const rulesDeploy = (_a = context === null || context === void 0 ? void 0 : context.firestore) === null || _a === void 0 ? void 0 : _a.rulesDeploy;
    if (!context.firestoreRules || !rulesDeploy) {
        return;
    }
    await rulesDeploy.createRulesets(rulesDeploy_1.RulesetServiceType.CLOUD_FIRESTORE);
}
async function deployIndexes(context, options) {
    var _a;
    if (!context.firestoreIndexes) {
        return;
    }
    const indexesContext = (_a = context === null || context === void 0 ? void 0 : context.firestore) === null || _a === void 0 ? void 0 : _a.indexes;
    utils.logBullet(clc.bold(clc.cyan("firestore: ")) + "deploying indexes...");
    const firestoreIndexes = new api_1.FirestoreApi();
    await Promise.all(indexesContext.map(async (indexContext) => {
        const { databaseId, indexesFileName, indexesRawSpec } = indexContext;
        if (!indexesRawSpec) {
            logger_1.logger.debug(`No Firestore indexes present for ${databaseId} database.`);
            return;
        }
        const indexes = indexesRawSpec.indexes;
        if (!indexes) {
            logger_1.logger.error(`${databaseId} database index file must contain "indexes" property.`);
            return;
        }
        const fieldOverrides = indexesRawSpec.fieldOverrides || [];
        try {
            await firestoreIndexes.deploy(options, indexes, fieldOverrides, databaseId);
        }
        catch (err) {
            if (err.status !== 404) {
                throw err;
            }
            await (0, utils_1.sleep)(1000);
            await firestoreIndexes.deploy(options, indexes, fieldOverrides, databaseId);
        }
        utils.logSuccess(`${clc.bold(clc.green("firestore:"))} deployed indexes in ${clc.bold(indexesFileName)} successfully for ${databaseId} database`);
    }));
}
async function default_1(context, options) {
    await createDatabase(context, options);
    await deployRules(context);
    await deployIndexes(context, options);
}
exports.default = default_1;
