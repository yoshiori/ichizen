"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createArchive = void 0;
const archiver = require("archiver");
const fs = require("fs");
const path = require("path");
const tmp = require("tmp");
const error_1 = require("../../error");
const fsAsync = require("../../fsAsync");
async function createArchive(config, projectRoot) {
    const tmpFile = tmp.fileSync({ prefix: `${config.backendId}-`, postfix: ".zip" }).name;
    const fileStream = fs.createWriteStream(tmpFile, {
        flags: "w",
        encoding: "binary",
    });
    const archive = archiver("zip");
    if (!projectRoot) {
        projectRoot = process.cwd();
    }
    const ignore = config.ignore || ["node_modules", ".git"];
    ignore.push("firebase-debug.log", "firebase-debug.*.log");
    const gitIgnorePatterns = parseGitIgnorePatterns(projectRoot);
    ignore.push(...gitIgnorePatterns);
    try {
        const files = await fsAsync.readdirRecursive({
            path: projectRoot,
            ignore: ignore,
            isGitIgnore: true,
        });
        for (const file of files) {
            const name = path.relative(projectRoot, file.name);
            archive.file(file.name, {
                name,
                mode: file.mode,
            });
        }
        await pipeAsync(archive, fileStream);
    }
    catch (err) {
        throw new error_1.FirebaseError("Could not read source directory. Remove links and shortcuts and try again.", { original: err, exit: 1 });
    }
    return { projectSourcePath: projectRoot, zippedSourcePath: tmpFile };
}
exports.createArchive = createArchive;
function parseGitIgnorePatterns(projectRoot, gitIgnorePath = ".gitignore") {
    const absoluteFilePath = path.resolve(projectRoot, gitIgnorePath);
    if (!fs.existsSync(absoluteFilePath)) {
        return [];
    }
    const lines = fs
        .readFileSync(absoluteFilePath)
        .toString()
        .split("\n")
        .map((line) => line.trim())
        .filter((line) => !line.startsWith("#") && !(line === ""));
    return lines;
}
async function pipeAsync(from, to) {
    from.pipe(to);
    await from.finalize();
    return new Promise((resolve, reject) => {
        to.on("finish", resolve);
        to.on("error", reject);
    });
}
